{"ast":null,"code":"import { toast } from 'react-toastify';\nimport { bellmanFord } from './bellmanFord';\nimport { generareDrum } from './generareDrum';\nexport const main = (n, matrice, setLoading, setDrum) => {\n  let i, j;\n  const l = [];\n  for (i = 0; i <= parseInt(n) + 1; i++) {\n    l[i] = [];\n  }\n  for (i = 1; i <= n; i++) {\n    for (j = 1; j <= n; j++) {\n      l[i][j] = 99999999;\n    }\n  }\n  const newL = bellmanFord(l, matrice);\n  if (newL[1][1] === -1) {\n    toast.error('Pozitia initiala este blocata!', {\n      autoClose: 1000\n    });\n    setLoading(true);\n    setDrum([0, 0]);\n    return;\n  } else if (newL[n][n] === 99999999) {\n    toast.error('Nu este nici un drum disponibil!', {\n      autoClose: 1000\n    });\n    setLoading(true);\n    setDrum([0, 0]);\n    return;\n  } else {\n    let afisam = {\n      textulet: \"Drumul minim are costul \",\n      valoare: newL[n][n]\n    };\n    const drumObject = generareDrum(newL, matrice);\n    setDrum(drumObject.drum);\n    toast.success('afisam', {\n      autoClose: 1000\n    });\n    //toast.success(newL[n][n], { autoClose: 1000 })\n  }\n};","map":{"version":3,"names":["toast","bellmanFord","generareDrum","main","n","matrice","setLoading","setDrum","i","j","l","parseInt","newL","error","autoClose","afisam","textulet","valoare","drumObject","drum","success"],"sources":["C:/Users/Antonia/Desktop/566/src/functions/doStuff.js"],"sourcesContent":["import { toast } from 'react-toastify';\r\nimport { bellmanFord } from './bellmanFord';\r\nimport { generareDrum } from './generareDrum';\r\n\r\nexport const main = (n, matrice, setLoading, setDrum) => {\r\n  let i, j;\r\n  const l = [];\r\n\r\n  for (i = 0; i <= parseInt(n) + 1; i++) {\r\n    l[i] = [];\r\n  }\r\n\r\n  for (i = 1; i <= n; i++) {\r\n    for (j = 1; j <= n; j++) {\r\n      l[i][j] = 99999999\r\n    }\r\n  }\r\n\r\n  const newL = bellmanFord(l, matrice);\r\n\r\n  if (newL[1][1] === -1) {\r\n    toast.error('Pozitia initiala este blocata!', { autoClose: 1000 })\r\n    setLoading(true)\r\n    setDrum([0, 0])\r\n\r\n    return\r\n  } else if (newL[n][n] === 99999999) {\r\n    toast.error('Nu este nici un drum disponibil!', { autoClose: 1000 })\r\n    setLoading(true)\r\n    setDrum([0, 0])\r\n\r\n    return\r\n  }\r\n  else{\r\n    let afisam = {\r\n      textulet : \"Drumul minim are costul \",\r\n      valoare : newL[n][n] \r\n    }\r\n    const drumObject = generareDrum(newL, matrice);\r\n    setDrum(drumObject.drum)\r\n    toast.success('afisam', { autoClose: 1000 })\r\n    //toast.success(newL[n][n], { autoClose: 1000 })\r\n  }\r\n}"],"mappings":"AAAA,SAASA,KAAK,QAAQ,gBAAgB;AACtC,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,YAAY,QAAQ,gBAAgB;AAE7C,OAAO,MAAMC,IAAI,GAAGA,CAACC,CAAC,EAAEC,OAAO,EAAEC,UAAU,EAAEC,OAAO,KAAK;EACvD,IAAIC,CAAC,EAAEC,CAAC;EACR,MAAMC,CAAC,GAAG,EAAE;EAEZ,KAAKF,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIG,QAAQ,CAACP,CAAC,CAAC,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAE;IACrCE,CAAC,CAACF,CAAC,CAAC,GAAG,EAAE;EACX;EAEA,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIJ,CAAC,EAAEI,CAAC,EAAE,EAAE;IACvB,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIL,CAAC,EAAEK,CAAC,EAAE,EAAE;MACvBC,CAAC,CAACF,CAAC,CAAC,CAACC,CAAC,CAAC,GAAG,QAAQ;IACpB;EACF;EAEA,MAAMG,IAAI,GAAGX,WAAW,CAACS,CAAC,EAAEL,OAAO,CAAC;EAEpC,IAAIO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;IACrBZ,KAAK,CAACa,KAAK,CAAC,gCAAgC,EAAE;MAAEC,SAAS,EAAE;IAAK,CAAC,CAAC;IAClER,UAAU,CAAC,IAAI,CAAC;IAChBC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAEf;EACF,CAAC,MAAM,IAAIK,IAAI,CAACR,CAAC,CAAC,CAACA,CAAC,CAAC,KAAK,QAAQ,EAAE;IAClCJ,KAAK,CAACa,KAAK,CAAC,kCAAkC,EAAE;MAAEC,SAAS,EAAE;IAAK,CAAC,CAAC;IACpER,UAAU,CAAC,IAAI,CAAC;IAChBC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAEf;EACF,CAAC,MACG;IACF,IAAIQ,MAAM,GAAG;MACXC,QAAQ,EAAG,0BAA0B;MACrCC,OAAO,EAAGL,IAAI,CAACR,CAAC,CAAC,CAACA,CAAC;IACrB,CAAC;IACD,MAAMc,UAAU,GAAGhB,YAAY,CAACU,IAAI,EAAEP,OAAO,CAAC;IAC9CE,OAAO,CAACW,UAAU,CAACC,IAAI,CAAC;IACxBnB,KAAK,CAACoB,OAAO,CAAC,QAAQ,EAAE;MAAEN,SAAS,EAAE;IAAK,CAAC,CAAC;IAC5C;EACF;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}